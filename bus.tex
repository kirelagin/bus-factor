\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[a4paper, hmargin={3.5cm, 2.0cm}, vmargin={1.5cm, 2.0cm}]{geometry}
\usepackage[bookmarks=true,unicode=true,pdfstartview={FitH}]{hyperref}
\usepackage{enumitem}
\usepackage{textcomp}

\setlength\parindent{0pt}
\setlength\parskip{0.15in}
\setlist{topsep=0pt}

\let\stdsection\section
\renewcommand\section{\newpage\stdsection}

\begin{document}

\section{Основные принципы гибких технологий разработки программного обеспечения}
    Гибкая методология разработки (англ. Agile software development) — это концептуальный каркас, в рамках которого выполняется разработка программного обеспечения. Существует несколько подобных методик.

    Большинство гибких методологий нацелены на минимизацию рисков путём сведения разработки к серии коротких циклов, называемых итерациями, которые обычно длятся две-три недели. Каждая итерация сама по себе выглядит как программный проект в миниатюре и включает все задачи, необходимые для выдачи мини-прироста по функциональности: планирование, анализ требований, проектирование, кодирование, тестирование и документирование. Хотя отдельная итерация, как правило, недостаточна для выпуска новой версии продукта, подразумевается, что гибкий программный проект готов к выпуску в конце каждой итерации. По окончании каждой итерации команда выполняет переоценку приоритетов разработки.

    Agile-методы делают упор на непосредственное общение лицом к лицу. Большинство agile-команд расположены в одном офисе, иногда называемом bullpen. Как минимум, она включает и «заказчиков» (product owner — заказчик или его полномочный представитель, определяющий требования к продукту; эту роль может выполнять менеджер проекта, бизнес-аналитик или клиент). Офис может также включать тестировщиков, дизайнеров интерфейса, технических писателей и менеджеров.

    Основной метрикой agile-методов является рабочий продукт. Отдавая предпочтение непосредственному общению, agile-методы уменьшают объем письменной документации по сравнению с другими методами. Это привело к критике этих методов, как недисциплинированных.

    Основные идеи:
    \begin{enumerate}
        \item личности и их взаимодействия важнее, чем процессы и инструменты;
        \item работающее программное обеспечение важнее, чем полная документация;
        \item сотрудничество с заказчиком важнее, чем контрактные обязательства;
        \item реакция на изменения важнее, чем следование плану.
    \end{enumerate}

    Принципы, которые разъясняет Agile Manifesto:
    \begin{enumerate}
        \item удовлетворение клиента за счёт ранней и бесперебойной поставки ценного ПО;
        \item приветствие изменений требований, даже в конце разработки (это может повысить конкурентоспособность полученного продукта);
        \item частая поставка рабочего ПО (каждый месяц или неделю или ещё чаще);
        \item тесное, ежедневное общение заказчика с разработчиками на протяжении всего проекта;
        \item проектом занимаются мотивированные личности, которые обеспечены нужными условиями работы, поддержкой и доверием;
        \item рекомендуемый метод передачи информации — личный разговор (лицом к лицу);
        \item работающее ПО — лучший измеритель прогресса;
        \item спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на неопределенный срок;
        \item постоянное внимание на улучшение технического мастерства и удобный дизайн;
        \item простота — искусство \emph{не} делать лишней работы;
        \item лучшие технические требования, дизайн и архитектура получаются у самоорганизованной команды;
        \item постоянная адаптация к изменяющимся обстоятельствам.
    \end{enumerate}

\section{Итеративный и инкрементальный процесс разработки программного обеспечения}
    Инкрементальный процесс: разработка по маленьким кусочкам.

    Итеративный процесс: выполнение работ параллельно с непрерывным анализом полученных результатов и корректировкой предыдущих этапов работы.

    Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл: планирование — реализация — проверка — корректировка (англ. plan-do-check-act cycle).

    Преимущества итеративного подхода:
    \begin{enumerate}
        \item снижение воздействия серьезных рисков на ранних стадиях проекта, что ведет к минимизации затрат на их устранение;
        \item организация эффективной обратной связи проектной команды с потребителем (а также заказчиками, стейкхолдерами) и создание продукта, реально отвечающего его потребностям;
        \item акцент усилий на наиболее важные и критичные направления проекта;
        \item непрерывное итеративное тестирование, позволяющее оценить успешность всего проекта в целом;
        \item раннее обнаружение конфликтов между требованиями, моделями и реализацией проекта;
        \item более равномерная загрузка участников проекта;
        \item эффективное использование накопленного опыта;
        \item реальная оценка текущего состояния проекта и, как следствие, большая уверенность заказчиков и непосредственных участников в его успешном завершении,
        \item затраты распределяются по всему проекту, а не группируются в его конце.
    \end{enumerate}

\section{Четыре переменных управления проектом: стоимость, качество, сроки и объем работ}
    \begin{enumerate}
        \item Стоимость — сложно управлять.
        \item Качество — понижение качества возвращается назад.%FIXME: што?
        \item Сроки — увеличить не очень просто.
        \item Объём работ — достаточно отрубить некоторую функциональность, и все в выигрыше.
    \end{enumerate}

\section{Практики XP: разработка через тестирование}
    Разработка через тестирование (test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.

    Кент Бек, считающийся изобретателем этой техники, утверждал в 2003 году, что разработка через тестирование поощряет простой дизайн и внушает уверенность (inspires confidence).

    В 1999 году при своем появлении разработка через тестирование была тесно связана с концепцией «сначала тест» (test-first), применяемой в экстремальном программировании, однако позже выделилась как независимая методология.

    Тест — это процедура, которая позволяет либо подтвердить, либо опровергнуть работоспособность кода. Когда программист проверяет работоспособность разработанного им кода, он выполняет тестирование вручную. В данном контексте тест состоит из двух этапов: стимулирование кода и проверки результатов его работы. Автоматический тест выполняется иначе: вместо программиста стимулированием кода и проверкой результатов занимается компьютер, который отображает на экране результат выполнения теста: код работоспособен или код неработоспособен.%FIXME: стимулирование кода? о_0

    Методика разработки через тестирование позволяет получить ответы на вопросы об организации автоматических тестов и выработке определенных навыков тестирования.

\section{Разработка через тестирование: типичный цикл разработки через тестирование}
    \begin{enumerate}
        \item Тест.
        \item Проверка, что не компилируется.
        \item Заглушки кода (30 мин.).
        \item Проверка, что тест не работает.
        \item Простая реализация.
        \item Проверка, что работает.
        \item Работают все тесты.
        \item Рефакторинг.
        \item Работают все тесты.
        \item Return.
    \end{enumerate}

\section{Разработка через тестирование: модульные и функциональные тесты}
    2 вида тестирования:
    \begin{enumerate}
        \item модульные (unit-testing),
        \item функциональные (приёмочные, acceptance-testing).
    \end{enumerate}

    Разработчик не может быть уверен в правильности написанного им кода до тех пор, пока не сработают абсолютно все тесты модулей разрабатываемой им системы. Тесты модулей позволяют разработчикам убедиться в том, что их код работает корректно. Они также помогают другим разработчикам понять, зачем нужен тот или иной фрагмент кода и как он функционирует. Тесты модулей также позволяют разработчику без каких-либо опасений выполнять рефакторинг (refactoring).

    Приемочные тесты позволяют убедиться в том, что система действительно обладает заявленными возможностями. Кроме того, приемочные тесты позволяют проверить корректность функционирования разрабатываемого продукта.

\section{Практики XP: парное программирование}
    Техника программирования, при которой весь исходный код создаётся парами людей, программирующих одну задачу, сидя за одним рабочим местом. Один программист управляет компьютером и, в основном, думает над кодированием в деталях. Другой программист сосредоточен на картине в целом и непрерывно просматривает код, производимый первым программистом. Время от времени они меняются ролями, обычно, каждые полчаса.
    Преимущества:
    \begin{enumerate}
        \item Программисты в паре чаще «делают то, что нужно» и реже устраивают длинные перерывы.
        \item Партнёры в паре менее склонны к неудачным решениям и производят более качественный код.
        \item Коллективное владение (пары меняются) означает, что каждый несёт ответственность за весь код. Таким образом, каждый вправе вносить изменения в любой участок кода. Парное программирование поддерживает эту практику: работая в парах, все программисты получают доступ ко всем частям кода. Важное преимущество коллективного владения кодом заключается в том, что оно ускоряет процесс разработки, поскольку при появлении ошибки её может устранить любой программист.
        \item Каждый, даже начинающий программист, знает что-то, чего не знают другие. Парное программирование — безболезненный способ распространить эти знания.
        \item Ошибки обнаруживаются сразу же, как только появились, это позволяет экономить и время, и деньги. Команда разработчиков сплочается, что позволяет закончить работу раньше и более лучше.
    \end{enumerate}

    Виды:
    \begin{enumerate}
        \item Удалённое парное программирование: два программиста находятся в разных местах, но работают, например, на удалённом рабочем столе.
        \item Пинг-понг:
        \begin{enumerate}
            \item наблюдатель пишет тест, на котором падает;
            \item программисты меняются ролями;
            \item бывший наблюдатель подправляет код;
            \item повторяем цикл.
        \end{enumerate}
    \end{enumerate}

\section{Практики XP: коллективное владение кодом}
    Коллективное владение означает, что каждый член команды несёт ответственность за весь исходный код. Таким образом, каждый вправе вносить изменения в любой участок программы. Парное программирование поддерживает эту практику: работая в разных парах, все программисты знакомятся со всеми частями кода системы. Важное преимущество коллективного владения кодом в том, что оно ускоряет процесс разработки, поскольку при появлении ошибки её может устранить любой программист.

    Давая каждому программисту право изменять код, мы получаем риск появления ошибок, вносимых программистами, которые считают что знают, что делают, но не рассматривают некоторые зависимости. Хорошо определённые UNIT-тесты решают эту проблему: если нерассмотренные зависимости порождают ошибки, то следующий запуск UNIT-тестов будет неудачным.

\section{Практики XP: 40-часовая рабочая неделя}
    Устойчивый темп — программист не должен работать более, чем 40 часов в неделю. Если на какой-то неделе программист переработал, то на следующей он не должен перерабатывать. Это легко реализуется в экстремальном программировании, т.к. циклы разработки уже короткие. Усталый работник — плохой работник.

    Ключ, который помогает реализовать устойичый темп, — слияние кода и постоянная покрытость кода тестами. Постоянный рефакторинг помогает программистам понимать, что происходит.

\section{Практики XP: простой дизайн}
    Простота дизайна XP исходит из того, что в процессе работы условия задачи могут неоднократно измениться, а значит, разрабатываемый продукт не следует проектировать заблаговременно целиком и полностью. Если в самом начале работы вы пытаетесь от начала и до конца детально спроектировать систему, вы напрасно тратите время. XP предполагает, что проектирование — это настолько важный процесс, что его необходимо выполнять постоянно, в течение всего времени работы над проектом. Проектирование должно выполняться небольшими этапами, с учетом постоянно изменяющихся требований. В каждый момент времени мы пытаемся использовать наиболее простой дизайн, который подходит для решения текущей задачи. При этом мы меняем его по мере того, как условия задачи меняются.

    Составляющие:
    \begin{enumerate}
        \item намерения программиста,%FIXME: што
        \item нет дублирования,
        \item работают все тесты,
        \item минимальное количество кода.
    \end{enumerate}

\section{Практики XP: рефакторинг}
    Рефакторинг (англ. refactoring) — процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое, программисту легче проследить за его правильностью, и в то же время вся последовательность может привести к существенной перестройке программы и улучшению её согласованности и четкости.

    В программировании термин «рефакторинг» означает изменение исходного кода программы без изменения его внешнего поведения. В экстремальном программировании и других гибких методологиях рефакторинг является неотъемлемой частью цикла разработки ПО: разработчики попеременно то создают новые тесты и функциональность, то выполняют рефакторинг кода для улучшения его логичности и прозрачности. Автоматическое юнит-тестирование позволяет убедиться, что рефакторинг не разрушил существующую функциональность.

    Иногда под рефакторингом неправильно подразумевают коррекцию кода с заранее оговоренными правилами отступа, перевода строк, внесения комментариев и прочими визуально значимыми изменениями, которые никак не отражаются на процессе компиляции, с целью обеспечения лучшей читаемости кода.

    Рефакторинг изначально не предназначен для исправления ошибок и добавления новой функциональности, он вообще не меняет поведение программного обеспечения и это помогает избежать ошибок и облегчить добавление функциональности. Он выполняется для улучшения понятности кода или изменения его структуры, для удаления «мёртвого кода» — всё это для того, чтобы в будущем код было легче поддерживать и развивать. В частности, добавление в программу нового поведения может оказаться сложным с существующей структурой — в этом случае разработчик может выполнить необходимый рефакторинг, а уже затем добавить новую функциональность.

    Это может быть перемещение поля из одного класса в другой, вынесение фрагмента кода из метода и превращение его в самостоятельный метод или даже перемещение кода по иерархии классов. Каждый отдельный шаг может показаться элементарным, но совокупный эффект таких малых изменений в состоянии радикально улучшить проект или даже предотвратить распад плохо спроектированной программы.

\section{Практики XP: постоянная интеграция}
    Постоянная интеграция — это практика разработки программного обеспечения, которая заключается в выполнении частых автоматизированных сборок проекта для скорейшего выявления и решения интеграционных проблем. В обычном проекте, где над разными частями системы разработчики трудятся независимо, стадия интеграции является заключительной. Она может непредсказуемо задержать окончание работ. Переход к непрерывной интеграции позволяет снизить трудоёмкость интеграции и сделать её более предсказуемой за счет наиболее раннего обнаружения и устранения ошибок и противоречий.

    Требования к проекту:
    \begin{enumerate}
        \item исходные коды и все, что необходимо для сборки и тестирования проекта, хранится в репозитории системы управления версиями;
        \item операции копирования из репозитория, сборки и тестирования всего проекта автоматизированы и легко вызываются из внешней программы.
    \end{enumerate}

    Организация:
    \begin{itemize}
        \item На выделенном сервере организуется служба, в задачи которой входит:
        \begin{enumerate}
            \item получение исходного кода из репозитория;
            \item сборка проекта;
            \item выполнение тестов;
            \item развёртывание готового проекта;
            \item отправка отчетов.
        \end{enumerate}

        \item Локальная сборка может осуществляться:
        \begin{enumerate}
            \item по внешнему запросу,
            \item по расписанию,
            \item по факту обновления репозитория;
            \item по другим критериям.
        \end{enumerate}

        \item Сборка по расписанию:
        \begin{itemize}
            \item В случае сборки по расписанию (англ. daily build — рус. ежедневная сборка), они, как правило, проводятся каждой ночью в автоматическом режиме — ночные сборки (чтобы к началу рабочего дня были готовы результаты тестирования). Для различения дополнительно вводится система нумерации сборок — обычно, каждая сборка нумеруется натуральным числом, которое увеличивается с каждой новой сборкой. Исходные тексты и другие исходные данные при взятии их из репозитория системы контроля версий помечаются номером сборки. Благодаря этому, точно такая же сборка может быть точно воспроизведена в будущем — достаточно взять исходные данные по нужной метке и запустить процесс снова. Это даёт возможность повторно выпускать даже очень старые версии программы с небольшими исправлениями.
        \end{itemize}
    \end{itemize}

    Преимущества:
    \begin{enumerate}
        \item проблемы интеграции выявляются и исправляются быстро, что оказывается дешевле;
        \item немедленный прогон модульных тестов для свежих изменений;
        \item постоянное наличие текущей стабильной версии вместе с продуктами сборок — для тестирования, демонстрации, и т.п.;
        \item немедленный эффект от неполного или неработающего кода приучает разработчиков к работе в итеративном режиме с более коротким циклом.
    \end{enumerate}

    Недостатки:
    \begin{enumerate}
        \item затраты на поддержку работы непрерывной интеграции;
        \item потенциальная необходимость в выделенном сервере под нужды непрерывной интеграции;
        \item немедленный эффект от неполного или неработающего кода отучает разработчиков от выполнения периодических резервных включений кода в репозиторий [в случае использования системы управления версиями исходного кода с поддержкой ветвления, эта проблема может решаться созданием отдельной «ветки» (англ. branch) проекта для внесения крупных изменений (код, разработка которого до работоспособного варианта займет несколько дней, но желательно более частое резервное копирование в репозиторий). По окончании разработки и индивидуального тестирования такой ветки, она может быть объединена (англ. merge) с основным кодом или «стволом» (англ. trunk) проекта].
    \end{enumerate}

\section{Практики XP: игра в планирование}
    Основная цель игры в планирование — быстро сформировать приблизительный план работы и постоянно обновлять его по мере того, как условия задачи становятся все более четкими. Артефактами игры в планирование является набор бумажных карточек, на которых записаны пожелания заказчика (customer stories), и приблизительный план работы по выпуску следующих одной или нескольких небольших версий продукта. Критическим фактором, благодаря которому такой стиль планирования оказывается эффективным, является то, что в данном случае заказчик отвечает за принятие бизнес-решений, а команда разработчиков отвечает за принятие технических решений. Если не выполняется это правило, весь процесс распадается на части.

\section{Scrum: общее описание}
    Scrum — это набор принципов, на которых строится процесс разработки, позволяющий в жёстко фиксированные небольшие промежутки времени (спринты от 2 до 4 недель) предоставлять конечному пользователю работающее ПО с новыми возможностями, для которых определён наибольший приоритет. Возможности ПО к реализации в очередном спринте определяются в начале спринта на этапе планирования и не могут изменяться на всём его протяжении. При этом строго фиксированная небольшая длительность спринта придаёт процессу разработки предсказуемость и гибкость.

    Главные действующие роли в Scrum: 
    \begin{itemize}
        \item ScrumMaster — тот, кто ведёт Scrum митинги и следит, чтобы при этом соблюдались все принципы Scrum (роль не предполагает ничего кроме корректного ведения самого Scrum'а, руководитель проекта скорее относится к Product Owner и не должен являться ScrumMaster);
        \item Владелец Продукта (Product Owner) — человек, который представляет интересы конечных пользователей и других заинтересованных в продукте сторон;
        \item кросс-функциональная Команда (Scrum Team), состоящая как из разработчиков, так и из тестировщиков, архитекторов, аналитиков и т.д. (при этом размер команды в идеале составляет 7±2 человека). Команда является единственным полностью вовлечённым участником разработки, и отвечает за результат как единое целое. Никто кроме Команды не может вмешиваться в процесс разработки на протяжении спринта.
    \end{itemize}

    На протяжении каждого спринта создаётся функциональный рост программного обеспечения. Набор возможностей, которые реализуются в каждом спринте, происходят из этапа, называемого product backlog (документация запросов на выполнение работ), обладающего наивысшим приоритетом по уровню требований к работе, который должен быть выполнен. Запросы на выполнение работ (backlog items), определенных на протяжении совета по планированию спринта (sprint planning meeting), перемещаются в этап спринта. На протяжении этого собрания Владелец Продукта информирует о заданиях, которые должны быть выполнены. Тогда Команда определяет, сколько из желаемого они могут выполнить, чтобы завершить необходимые части на протяжении следующего спринта. Во время спринта команда выполняет определенный фиксированный список заданий (т.н. sprint backlog). На протяжении этого периода никто не имеет права менять список требований к работе, что следует понимать как заморозку требований (requirements) во время спринта.

\section{Scrum: роли}
    \subsection{Свиньи}
    Свиньи полностью включены в проект, в Скрам процесс, они как бы едины со «своей сущностью» на производственной линии.
    \begin{enumerate}
        \item Владелец Продукта (Product Owner);
        \item Руководитель (ScrumMaster);
        \item Команда (Scrum Team).
    \end{enumerate}

    \subsection{Куры}
    \begin{enumerate}
        \item Пользователи (Users);
        \item Клиенты, Продавцы (Stakeholders);
        \item Эксперты-консультанты (Consulting Experts).
    \end{enumerate}

\section{Scrum: фазы проекта}
    \begin{enumerate}
        \item Pre-game (предварительное планирование, например — бюджета);
        \item Разработка — спринты;
        \item Post-game (сопроводительные материалы, User-manual, сайт и т.д.).
    \end{enumerate}

\section{Scrum: сессии}
    \begin{enumerate}
        \item Сессия планирования:
        \begin{itemize}
            \item выбирается объём работ, обязательства по выполнению которых за спринт принимает на себя команда;
            \item обсуждается и определяется, каким образом будет реализован этот объём работ;
            \item каждая запись в Product Backlog, принятая к реализации, разбивается на подзадачи, которые оцениваются в идеальных человеко-часах;
            \item ограничена сверху 4-8 часами в зависимости от продолжительности итерации, опыта команды и т. п.;
        \end{itemize}

        \item Daily Scrun Meeting:
        \begin{itemize}
            \item начинается точно вовремя;
            \item все могут наблюдать, но только «свиньи» говорят;
            \item длится не более 15 минут;
            \item проводится в одном и том же месте в течение спринта;
            \item 3 вопроса каждому члену команды:
            \begin{itemize}
                \item Что сделано с момента предыдущего митинга до текущего?
                \item Что будет сделано с момента текущего митинга до следующего?
                \item Какие проблемы мешают достижению целей спринта? (Над решением этих проблем работает ScrumMaster. Обычно это решение проходит за рамками митинга и в составе лиц, непосредственно затронутых данным препятствием.)
            \end{itemize}
        \end{itemize}

        \item Demo Meeting:
        \begin{itemize}
            \item происходит в конце итерации (спринта);
            \item команда демонстрирует прирост функциональности продукта всем заинтересованным лицам;
            \item привлекается максимальное количество зрителей;
            \item все члены команды участвуют в демонстрации (один человек на демонстрацию или каждый показывает, что сделал за спринт);
            \item ограничена 4-мя часами в зависимости от продолжительности итерации и инкремента продукта.
        \end{itemize}

        \item Retrospective Meeting:
        \begin{itemize}
            \item все члены команды рассказывают о своём отношении к ходу прошедшего спринта;
            \item отвечают на два основных вопроса:
                \begin{itemize}
                    \item Что было сделано хорошо в прошедшем спринте?
                    \item Что надо улучшить или не допускать в следующем?
                 \end{itemize}
            \item выполняют улучшение процесса разработки (решают вопросы и фиксируют удачные решения).
        \end{itemize}
    \end{enumerate}

\section{Scrum: документы}
    Документы:
    \begin{enumerate}
        \item Product backlog — это документ, содержащий список требований к функциональности, которые упорядочены по степени важности. Product backlog представляет собой список того, что должно быть реализовано. Элементы этого списка называются «историями» (user story) или элементами backlog’a (backlog items). Product backlog открыт для редактирования для всех участников Scrum-процесса.
        \begin{itemize}
            \item Обязательные поля:
            \begin{enumerate}
                \item ID — уникальный идентификатор, порядковый номер, применяемый для идентификации историй в случае их переименования.
                \item Название (Name) — краткое описание истории. Оно должно быть однозначным, чтобы и разработчики, и product owner могли понять, о чем идёт речь и отличить одну историю от другой.
                \item Важность (Importance) — степень важности данной истории, по мнению product owner’a. Обычно представляет собой натуральное число, иногда для этой цели используются числа Фибоначчи. Чем больше значение, тем выше приоритет.
                \item Предварительная оценка (initial estimate) — начальная оценка объёма работ, необходимого для реализации истории по сравнению с другими историями. Измеряется в story point’ах. Приблизительно соответствует числу «идеальных человеко-часов».
                \item Как продемонстрировать (how to demo) — краткое пояснение того, как завершённая задача будет продемонстрирована в конце спринта. Данное поле может представлять собой код автоматизированного теста для приёмо-сдаточного испытания.
            \end{enumerate}
            \item Дополнительные поля (иногда, также, используются дополнительные поля в product backlog, в основном для того, чтобы помочь product owner’у определиться с его приоритетами):
            \begin{enumerate}
                \item Категория (track). Например, «панель управления» или «оптимизация». При помощи этого поля product owner может легко выбрать все пункты категории «оптимизация» и установить им низкий приоритет.
                \item Компоненты (components) — указывает, какие компоненты (например, база данных, сервер, клиент) будут затронуты при реализации истории. Данное поле состоит из группы checkbox’ов, которые отмечаются, если соответствующие компоненты требуют изменений.
                \item Инициатор запроса (requestor). Product owner может захотеть хранить информацию о всех заказчиках, заинтересованных в данной задаче. Это нужно для того, чтобы держать их в курсе дела о ходе выполнения работ.
                \item ID в системе учёта дефектов (bug tracking ID) — если вы используете отдельную систему для учёта дефектов (например, Jira), тогда в описании истории полезно хранить ссылки на все дефекты, которые к ней относятся.
            \end{enumerate}
        \end{itemize}
        \item Sprint backlog — содержит функциональность, выбранную Product Owner из Product Backlog. Все функции разбиты по задачам, каждая из которых оценивается командой. Каждый день команда оценивает объем работы, который нужно проделать для завершения задач, а также содержит возникшие проблемы при выполнении задания.
        \item Burndown chart — количество задач от времени, обнуляется к Demo-сессии. Рисуется Scrum-мастером.
    \end{enumerate}
\end{document}

